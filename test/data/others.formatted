-module(others).

-compile(export_all).

strange_infix_operators(A, B) -> bnot (-(A rem B)).

-define(OUT_OF_CONTEXT_CLAUSE, (true -> false) ).

-record(rec, {key, value}).

named_fun_expr() ->
  fun This(is) -> a;
      This(recursive) -> function;
      This(called) -> This(is)
  end.

catch_expr() ->
  catch this:train(with, all, its, arguments, {they, might, be, too, many, to, "handle"}).

comprehensions(Bin, List) ->
  BinToBin = bcTodoExpr,
  BinToList = lcTodoExpr,
  ListToBin = bcTodoExpr,
  ListToList = lcTodoExpr,
  {BinToBin, BinToList, ListToBin, ListToList}.

parentheses() ->
  { "does                            "
  , this
  , [ [code, <<"        look         ">>, like]
    , "lisp"
    , to
    , [{[<<"(      you or me or them?)">>]}]
    ]
  }.

receive_expr() -> receiveTodoExpr.

record_index_expr(List) -> lists:keyfind(a, record_indexTodoExpr, List).

try_expr_after() ->
  try to:open({the, door}) of
    my -> room or your;
    room -> {my, friend}
  catch {you_cant, Open} when Open -> it:was(Open)
  catch close:the(door, anyway)
  end,
  try with:no(catching)
  catch
    do:something({ to
                 , "clean up"
                 , <<"the">>
                 , [filthy, filthy, mess]
                 , you
                 , created
                 , "if you can"
                 })
  end.

bit_types(X) ->
  <<X:4/little-signed-integer-unit:8, (something:on(X)):32/big-unsigned-integer-unit:32>>.

multi_try_expr() ->
  try
    there:are(2),
    expressions:in(this_block)
  catch catchTodoExpr -> formatter:should(indent, A, Catch, Expression)
  end.
